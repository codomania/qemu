Secure Encrypted Virtualization (SEV) is a feature found on AMD processors.

SEV feature allows the memory contents of a virtual machine (VM) to be
transparently  encrypted with a key unique to the guest VM. The memory
controller contains a high performance encryption engine which can be
programmed with multiple keys for used by different VMs in the system.
The programming and management of these keys is handled by the AMD  Secure
Processor firmware which exposes commands for these tasks.

At highest level the SEV key management APIs are divided into two sections:

* Platform management commands
* Guest management commands

In this doc we will focus on Guest management commands. 

SEV is capable of supporting both light-weight virtual containers as well as
conventional VM within an enterprise cloud environment. In either case, there
are two parties concerned in the deployment of SEV guest: the guest owner and
the platform owner. For example, in a cloud environment, the platform owner
would be cloud vendor and the guest owner would be the user that wishes to run
their workload in the cloud.

1. Guest Management Commands
-----------------------------

The guest management commands provide the support for common guest lifecycle
events. These events include launching, running, snapshotting, migrating and
decommission guest. The guest management commands are issued through
KVM_MEMORY_ENCRYPTION_OPS ioctl.

1.1 Launch

When a guest is launched, its memory must first be encrypted using guest owners
key before SEV can be enabled in hardware. There are two types of launches:

1.1.1 unencrypted

Boot images (such as bios, kernel, initrd) provided by the guest owner to
bootstrap the guest is unencrypted. The firmware provides interfaces to
bootstrap the memory encryption for this purpose: LAUNCH_START, LAUNCH_UPDATE,
, LAUNCH_MEASURE and LAUNCH_FINISH. These four commands together generate a fresh
memory encryption key for the guest, encrypt guest memory and provide an
attestation of the successful launch.

LAUNCH_START is called first to create a cryptographic launch context within the
firmware. To create this context, guest owner must provide security policy,
public Diffie-Hellman key (PDH defined in section 12 of SEV key API management)
and session data. If PDH certificate blob is not provided by guest owner then
firmware will auto generate a key and use that key for memory encryption. Guest
owners PDH key is used to establish a cryptographic session with the guest owner
to negotiate keys used for attestation. The guest security policy is a 4-byte
data structure containing several flags that restrict what the hypervisor can do
on the running SEV guest.  If the hypervisor requests this guest to share key
with another SEV guest then hypervisor must set 'key-sharing' field in guest
security policy and a shared SEV handle must be provided in LAUNCH_START command.

LAUNCH_UPDATE_DATA encrypts the memory region using the cryptographic context
created via LAUNCH_START command. If required this command can be called multiple
times to encrypt different memory regions. The command also calculates the
measurement of the memory contents as it encrypts.

LAUNCH_MEASURE command can be used to retrieve the measurement of encrypted memory.
This measurement is a signature of the memory contents that can be sent to the
guest owner as an attestation that the memory was encrypted correctly by the
firmware. The guest owner may wait to provide the guest confidential information
until it can verify the attestation measurement. Since the guest owner knows the
initial contents of the guest at boot, the attestation measurement can be
verified by comparing it to what the guest owner expects.

LAUNCH_FINISH command finalizes the guest launch and destory's the cryptographic
context.

See SEV API Spec [1] 'Launching a guest' usage flow (Appendix A) for the
complete flow chart.

SEV support can be enabled via 'memory-encryption' parameters defined in
security-policy object.

Input to LAUNCH_START command can be provided through the properties defined in
'sev-launch-info' object.

e.g to launch SEV guest from unencrypted boot images

# ${QEMU} \
      -object sev-launch-info,id=launch0\
      -object sev-guest,id=sev0\
      -object security-policy,id=mypolicy,memory-encryption=sev0\
      -machine ...,security-policy=mypolicy

1.1.2 pre-encrypted

1.2 Snapshot

1.3 Restore

1.4 Live Migration

1.5 Debugging

Since memory contents of SEV guest is encrypted hence hypervisor access to the
guest memory will get a cipher text. If guest policy allows debugging, then
hypervisor can use SEV debug command to decrypt guest memory region for debug
purposes.

2. References
-----------------

AMD Memory Encryption whitepaper:
http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/12/AMD_Memory_Encryption_Whitepaper_v7-Public.pdf

Secure Encrypted Virutualization Key Management:
[1] http://support.amd.com/TechDocs/55766_SEV-KM API_Specification.pdf

KVM Forum slides:
http://www.linux-kvm.org/images/7/74/02x08A-Thomas_Lendacky-AMDs_Virtualizatoin_Memory_Encryption_Technology.pdf

AMD64 Architecture Programmer's Manual:
   http://support.amd.com/TechDocs/24593.pdf
   SME is section 7.10
   SEV is section 15.34

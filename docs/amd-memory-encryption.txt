Secure Encrypted Virtualization (SEV) is a feature found on AMD processors.

SEV feature allows the memory contents of a virtual machine (VM) to be
transparently  encrypted with a key unique to the guest VM. The memory
controller contains a high performance encryption engine which can be
programmed with multiple keys for used by different VMs in the system.
The programming and management of these keys are handled by the AMD Secure
Processor firmware which exposes commands for these tasks.

At highest level the SEV key management APIs are divided into two sections:

* Platform management commands
* Guest management commands

In this doc we will focus on Guest management commands.

SEV is capable of supporting both light-weight virtual containers as well as
conventional VM within an enterprise cloud environment. In either case, there
are two parties concerned in the deployment of SEV guest: the guest owner and
the platform owner. For example, in a cloud environment, the platform owner
would be cloud vendor and the guest owner would be the user that wishes to run
their workload in the cloud.

1. Guest Management Commands
-----------------------------

The guest management commands provide the support for common guest lifecycle
events. These events include launching, running, snapshotting, migrating and
decommission guest. The guest management commands are issued through
KVM_MEMORY_ENCRYPTION_OPS ioctl.

1.1 Launch

When a guest is launched, its memory must first be encrypted before SEV can be
enabled in hardware. There are two types of launches:

1.1.1 unencrypted

Boot images (such as bios) provided by the guest owner to bootstrap the guest
is unencrypted. The firmware provides commands to bootstrap the images for this
purpose: LAUNCH_START, LAUNCH_UPDATE, and LAUNCH_FINISH. These three commands
together generate a fresh memory encryption key for the guest, encrypt guest
memory and provide an attestation of the successful launch.

LAUNCH_START is called first to create a cryptographic launch context within the
firmware. To create this context, guest owner must provides guest policy, public
Diffie-Hellman key (PDH defined in section 12 of SEV key API management) and
session parameters.

The guest policy is a 4-byte data structure containing serveral flags that
restricts what can be done on running SEV guest. e.g POLICY.NODBG flag disallows
debugging this SEV guest and calling DEBUG_DECRYPT and DEBUG_ENCRYPT command on
this guest will fail. Similarly POLICY.NOKS is cleared then this guest allows
sharing its key with another SEV guest (See KM Spec section 3 and 6.2
for more details). The guest policy can be provided via the 'policy' property
(see below)

# ${QEMU} \
    sev-guest,id=sev0,policy=0x1...
    ....

Note that SEV guest policy should be provided by the guest owner, hypervisor
should passed the value "as-is". Any changes in policy by the hypervisor will
result in wrong measurement. If policy is not provided by the guest owner then a
value of zero is used.

Guest owners provided DH certificate and session parameters will be used to
establish a cryptographic session with the guest owner to negotiate keys used
for attestation. The DH certificate and session parameters can be provided
via the 'dh-cert-file' and 'session-file' property (see below)

# ${QEMU} \
    sev-guest,id=sev0,dh-cert-file=<file1>,session-file=<file2>

If DH certificate and session parameters are not specified then guest launch will
use 0h for both TEK (transport encryption key) and TIK (transport integrity key).

LAUNCH_UPDATE_DATA encrypts the memory region using the cryptographic context
created via LAUNCH_START command. If required this command can be called multiple
times to encrypt different memory regions. The command also calculates the
measurement of the memory contents as it encrypts.

LAUNCH_MEASURE command can be used to retrieve the measurement of encrypted memory.
This measurement is a signature of the memory contents that can be sent to the
guest owner as an attestation that the memory was encrypted correctly by the
firmware. The guest owner may wait to provide the guest confidential information
until it can verify the attestation measurement. Since the guest owner knows the
initial contents of the guest at boot, the attestation measurement can be
verified by comparing it to what the guest owner expects.

LAUNCH_FINISH command finalizes the guest launch and destory's the cryptographic
context.

See SEV API Spec [1] 'Launching a guest' usage flow (Appendix A) for the
complete flow chart.

SEV support can be enabled via 'memory-encryption' parameters defined in
machine object.

e.g to launch SEV guest

# ${QEMU} \
      -object sev-guest,id=sev0\
      -machine ...,memory-encryption=sev0

1.1.2 pre-encrypted

1.2 Live Migration

1.3 Snapshot

1.4 Restore

1.5 Debugging

Since memory contents of SEV guest is encrypted hence hypervisor access to the
guest memory will get a cipher text. If guest policy allows debugging, then
hypervisor can use SEV debug command to decrypt guest memory region for debug
purposes.

2. References
-----------------

AMD Memory Encryption whitepaper:
http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/12/AMD_Memory_Encryption_Whitepaper_v7-Public.pdf

Secure Encrypted Virutualization Key Management:
[1] http://support.amd.com/TechDocs/55766_SEV-KM API_Specification.pdf

KVM Forum slides:
http://www.linux-kvm.org/images/7/74/02x08A-Thomas_Lendacky-AMDs_Virtualizatoin_Memory_Encryption_Technology.pdf

AMD64 Architecture Programmer's Manual:
   http://support.amd.com/TechDocs/24593.pdf
   SME is section 7.10
   SEV is section 15.34
